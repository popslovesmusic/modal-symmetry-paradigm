{
  // ═══════════════════════════════════════════════════════════════════════
  // MBC BOOLEAN GATE: XOR (Exclusive OR)
  // Monistic Box Calculus - Symbolic Execution Layer
  // ═══════════════════════════════════════════════════════════════════════

  metadata: {
    gate_type: "boolean",
    gate_name: "XOR",
    gate_symbol: "⊕",
    version: "1.0.0",
    layer: "MBC",
    classification: "Symbolic Tool",
    role: "Execute formal reasoning inside boxes",
    note: "Fundamental for parity checking and inequality testing"
  },

  logical_definition: {
    operation: "exclusive disjunction",
    arity: "binary (typically 2 inputs, n-ary extension via parity)",
    composition: "(A ∨ B) ∧ ¬(A ∧ B) or equivalently (A ∧ ¬B) ∨ (¬A ∧ B)",

    truth_table_binary: [
      { A: false, B: false, output: false },
      { A: false, B: true,  output: true  },
      { A: true,  B: false, output: true  },
      { A: true,  B: true,  output: false }
    ],

    semantic_interpretation: "Returns true if inputs differ (odd number of true inputs)",

    algebraic_properties: [
      "Commutative: A ⊕ B = B ⊕ A",
      "Associative: (A ⊕ B) ⊕ C = A ⊕ (B ⊕ C)",
      "Identity element: A ⊕ false = A",
      "Self-inverse: A ⊕ A = false",
      "Involution: A ⊕ B ⊕ B = A",
      "NOT via XOR: ¬A = A ⊕ true"
    ]
  },

  implementation: {
    input_schema: {
      type: "array",
      minItems: 2,
      items: { type: "boolean" }
    },

    output_schema: {
      type: "boolean"
    },

    algorithm: {
      description: "For n-ary XOR, return true if odd number of inputs are true (parity check)",
      pseudocode: `
        function XOR(inputs):
          count_true = 0
          for each input in inputs:
            if input == true:
              count_true++
          return (count_true % 2 == 1)
      `,
      complexity: {
        time: "O(n)",
        space: "O(1)"
      }
    },

    binary_optimization: {
      description: "For binary XOR, simply check inequality",
      pseudocode: "XOR(A, B) = (A != B)"
    }
  },

  mbc_usage: {
    typical_applications: [
      "Inequality testing (A differs from B)",
      "Parity checking",
      "Toggle/flip operations",
      "Mutual exclusion logic",
      "Change detection"
    ],

    example_use_cases: [
      {
        scenario: "Detect state change",
        expression: "previous_state ⊕ current_state",
        interpretation: "True if state changed"
      },
      {
        scenario: "Mutual exclusion routing",
        expression: "route_A ⊕ route_B",
        interpretation: "Exactly one route must be taken, not both or neither"
      },
      {
        scenario: "Parity invariant",
        expression: "box_1 ⊕ box_2 ⊕ box_3",
        interpretation: "Odd number of boxes must be active"
      }
    ]
  },

  invariant_guarantees: {
    preserves_boolean_type: true,
    preserves_determinism: true,
    preserves_referential_transparency: true,
    side_effect_free: true,
    implements_parity: true
  },

  test_vectors: [
    { inputs: [false, false], expected_output: false },
    { inputs: [false, true], expected_output: true },
    { inputs: [true, false], expected_output: true },
    { inputs: [true, true], expected_output: false },
    { inputs: [true, true, true], expected_output: true },
    { inputs: [true, true, true, true], expected_output: false }
  ]
}
